"use client";

import { generateClient } from "aws-amplify/data";
import type { Schema } from "@/amplify/data/resource";

const client = generateClient<Schema>();

export interface MeetingData {
  id?: string;
  organizationId: string;
  title: string;
  channelName: string;
  status: "SCHEDULED" | "LIVE" | "COMPLETED" | "CANCELLED";
  startedAt?: string;
  endedAt?: string;
  createdBy: string;
  participants: string[];
  recordingUrl?: string;
}

export interface TranscriptData {
  meetingId: string;
  userId: string;
  userName: string;
  text: string;
  timestamp: string;
  confidence?: number;
  processed?: boolean;
}

export interface TaskData {
  organizationId: string;
  meetingId?: string;
  title: string;
  description?: string;
  assignedTo?: string;
  assignedBy: string;
  status: "TODO" | "IN_PROGRESS" | "IN_REVIEW" | "COMPLETED" | "BLOCKED";
  priority: "LOW" | "MEDIUM" | "HIGH" | "URGENT";
  dueDate?: string;
  tags?: string[];
  autoGenerated?: boolean;
  transcriptReference?: string;
}

export interface TicketData {
  organizationId: string;
  taskId: string;
  type: "DEADLINE_EXTENSION" | "RESOURCE_REQUEST" | "CLARIFICATION" | "BLOCKER" | "OTHER";
  subject: string;
  description: string;
  createdBy: string;
  assignedTo?: string;
  status: "OPEN" | "IN_REVIEW" | "RESOLVED" | "REJECTED";
  priority: "LOW" | "MEDIUM" | "HIGH";
}

// Meeting Operations
export async function createMeeting(meeting: MeetingData) {
  const { data, errors } = await client.models.Meeting.create({
    ...meeting,
    createdAt: new Date().toISOString(),
    updatedAt: new Date().toISOString(),
  });
  
  if (errors) throw new Error(errors[0]?.message || "Failed to create meeting");
  return data;
}

export async function updateMeeting(id: string, updates: Partial<MeetingData>) {
  const { data, errors } = await client.models.Meeting.update({
    id,
    ...updates,
    updatedAt: new Date().toISOString(),
  });
  
  if (errors) throw new Error(errors[0]?.message || "Failed to update meeting");
  return data;
}

export async function getMeetingsByOrganization(organizationId: string) {
  const { data, errors } = await client.models.Meeting.list({
    filter: { organizationId: { eq: organizationId } },
  });
  
  if (errors) throw new Error(errors[0]?.message || "Failed to fetch meetings");
  return data || [];
}

export async function getMeetingById(id: string) {
  const { data, errors } = await client.models.Meeting.get({ id });
  
  if (errors) throw new Error(errors[0]?.message || "Failed to fetch meeting");
  return data;
}

// Transcript Operations
export async function createTranscript(transcript: TranscriptData) {
  const { data, errors } = await client.models.Transcript.create({
    ...transcript,
    processed: transcript.processed ?? false,
    createdAt: new Date().toISOString(),
  });
  
  if (errors) throw new Error(errors[0]?.message || "Failed to create transcript");
  return data;
}

export async function getTranscriptsByMeeting(meetingId: string) {
  const { data, errors } = await client.models.Transcript.list({
    filter: { meetingId: { eq: meetingId } },
  });
  
  if (errors) throw new Error(errors[0]?.message || "Failed to fetch transcripts");
  return data || [];
}

export async function getUnprocessedTranscripts(meetingId: string) {
  const { data, errors } = await client.models.Transcript.list({
    filter: {
      meetingId: { eq: meetingId },
      processed: { eq: false },
    },
  });
  
  if (errors) throw new Error(errors[0]?.message || "Failed to fetch unprocessed transcripts");
  return data || [];
}

export async function markTranscriptProcessed(id: string) {
  const { data, errors } = await client.models.Transcript.update({
    id,
    processed: true,
  });
  
  if (errors) throw new Error(errors[0]?.message || "Failed to update transcript");
  return data;
}

// Task Operations
export async function createTask(task: TaskData) {
  const { data, errors } = await client.models.Task.create({
    ...task,
    autoGenerated: task.autoGenerated ?? false,
    createdAt: new Date().toISOString(),
    updatedAt: new Date().toISOString(),
  });
  
  if (errors) throw new Error(errors[0]?.message || "Failed to create task");
  return data;
}

export async function updateTask(id: string, updates: Partial<TaskData> & { completedAt?: string }) {
  const { data, errors } = await client.models.Task.update({
    id,
    ...updates,
    updatedAt: new Date().toISOString(),
  });
  
  if (errors) throw new Error(errors[0]?.message || "Failed to update task");
  return data;
}

export async function getTasksByOrganization(organizationId: string) {
  const { data, errors } = await client.models.Task.list({
    filter: { organizationId: { eq: organizationId } },
  });
  
  if (errors) throw new Error(errors[0]?.message || "Failed to fetch tasks");
  return data || [];
}

export async function getTasksByMeeting(meetingId: string) {
  const { data, errors } = await client.models.Task.list({
    filter: { meetingId: { eq: meetingId } },
  });
  
  if (errors) throw new Error(errors[0]?.message || "Failed to fetch meeting tasks");
  return data || [];
}

export async function getTasksByAssignee(userId: string) {
  const { data, errors } = await client.models.Task.list({
    filter: { assignedTo: { eq: userId } },
  });
  
  if (errors) throw new Error(errors[0]?.message || "Failed to fetch assigned tasks");
  return data || [];
}

// Ticket Operations
export async function createTicket(ticket: TicketData) {
  const { data, errors } = await client.models.Ticket.create({
    ...ticket,
    createdAt: new Date().toISOString(),
    updatedAt: new Date().toISOString(),
  });
  
  if (errors) throw new Error(errors[0]?.message || "Failed to create ticket");
  return data;
}

export async function updateTicket(id: string, updates: Partial<TicketData> & { resolution?: string; resolvedAt?: string }) {
  const { data, errors } = await client.models.Ticket.update({
    id,
    ...updates,
    updatedAt: new Date().toISOString(),
  });
  
  if (errors) throw new Error(errors[0]?.message || "Failed to update ticket");
  return data;
}

export async function getTicketsByOrganization(organizationId: string) {
  const { data, errors } = await client.models.Ticket.list({
    filter: { organizationId: { eq: organizationId } },
  });
  
  if (errors) throw new Error(errors[0]?.message || "Failed to fetch tickets");
  return data || [];
}

export async function getTicketsByTask(taskId: string) {
  const { data, errors } = await client.models.Ticket.list({
    filter: { taskId: { eq: taskId } },
  });
  
  if (errors) throw new Error(errors[0]?.message || "Failed to fetch task tickets");
  return data || [];
}

export async function getOpenTickets(organizationId: string) {
  const { data, errors } = await client.models.Ticket.list({
    filter: {
      organizationId: { eq: organizationId },
      status: { eq: "OPEN" },
    },
  });
  
  if (errors) throw new Error(errors[0]?.message || "Failed to fetch open tickets");
  return data || [];
}

// Organization Operations
export async function getOrganizationMembers(organizationId: string) {
  const { data, errors } = await client.models.UserProfile.list({
    filter: { organizationId: { eq: organizationId } },
  });
  
  if (errors) throw new Error(errors[0]?.message || "Failed to fetch organization members");
  return data || [];
}

export async function inviteToOrganization(organizationId: string, email: string, invitedBy: string) {
  const expiresAt = new Date();
  expiresAt.setDate(expiresAt.getDate() + 7); // 7 days expiry

  const { data, errors } = await client.models.OrganizationInvite.create({
    organizationId,
    email,
    status: "PENDING",
    invitedBy,
    createdAt: new Date().toISOString(),
    expiresAt: expiresAt.toISOString(),
  });
  
  if (errors) throw new Error(errors[0]?.message || "Failed to create invite");
  return data;
}

export async function getPendingInvites(organizationId: string) {
  const { data, errors } = await client.models.OrganizationInvite.list({
    filter: {
      organizationId: { eq: organizationId },
      status: { eq: "PENDING" },
    },
  });
  
  if (errors) throw new Error(errors[0]?.message || "Failed to fetch pending invites");
  return data || [];
}
