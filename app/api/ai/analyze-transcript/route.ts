import { NextRequest, NextResponse } from "next/server";
import { createTask, getUnprocessedTranscripts, markTranscriptProcessed, getMeetingById } from "@/lib/database-operations";

// Groq API for LLM analysis
const GROQ_API_URL = "https://api.groq.com/openai/v1/chat/completions";
const GROQ_MODEL = "llama-3.1-8b-instant"; // Fast model for real-time

interface DetectedTask {
  title: string;
  description: string;
  assignedTo?: string;
  assignedToName?: string;
  priority: "LOW" | "MEDIUM" | "HIGH" | "URGENT";
  dueDate?: string;
  confidence: number;
}

export async function POST(request: NextRequest) {
  try {
    const { meetingId, text } = await request.json();

    if (!meetingId || !text) {
      return NextResponse.json(
        { error: "Missing meetingId or text" },
        { status: 400 }
      );
    }

    // Analyze the transcript text for task assignments
    const detectedTasks = await analyzeTranscriptForTasks(text);

    // Create tasks in database if high confidence
    const createdTasks = [];
    for (const task of detectedTasks) {
      if (task.confidence >= 0.7) {
        try {
          // Get meeting details
          const meeting = await getMeetingById(meetingId);
          if (!meeting) continue;

          const createdTask = await createTask({
            organizationId: meeting.organizationId,
            meetingId: meetingId,
            title: task.title,
            description: task.description,
            assignedTo: task.assignedTo,
            assignedBy: meeting.createdBy,
            status: "TODO",
            priority: task.priority,
            dueDate: task.dueDate,
            autoGenerated: true,
            tags: ["ai-generated", "meeting"],
          });

          createdTasks.push(createdTask);
        } catch (error) {
          console.error("Error creating task:", error);
        }
      }
    }

    return NextResponse.json({
      success: true,
      tasksDetected: detectedTasks.length,
      tasksCreated: createdTasks.length,
      tasks: createdTasks,
    });
  } catch (error) {
    console.error("AI analysis error:", error);
    return NextResponse.json(
      { error: "AI analysis failed" },
      { status: 500 }
    );
  }
}

async function analyzeTranscriptForTasks(
  text: string
): Promise<DetectedTask[]> {
  if (!process.env.GROQ_KEY) {
    console.error("GROQ_KEY not configured");
    return [];
  }

  try {
    const prompt = `You are an AI assistant that analyzes meeting transcripts to detect task assignments.

Analyze the following meeting transcript and identify any tasks being assigned to people.

Look for patterns like:
- "[Person], can you [task]"
- "I need [Person] to [task]"
- "[Person] will [task]"
- "Let's have [Person] [task]"
- "[Task] should be done by [Person]"

Extract:
1. Task title (concise action)
2. Task description (more detail)
3. Person assigned (if mentioned)
4. Priority (LOW, MEDIUM, HIGH, URGENT)
5. Due date (if mentioned, in YYYY-MM-DD format)
6. Confidence score (0.0 to 1.0)

Transcript:
"""
${text}
"""

Respond with a JSON array of detected tasks. If no tasks found, return an empty array.

Example response:
[
  {
    "title": "Draft product roadmap",
    "description": "Create initial draft of the product roadmap document",
    "assignedToName": "Alex Rivera",
    "priority": "HIGH",
    "dueDate": "2025-12-06",
    "confidence": 0.95
  }
]`;

    const response = await fetch(GROQ_API_URL, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${process.env.GROQ_KEY}`,
      },
      body: JSON.stringify({
        model: GROQ_MODEL,
        messages: [
          {
            role: "system",
            content: "You are a task detection AI. Always respond with valid JSON only, no additional text.",
          },
          {
            role: "user",
            content: prompt,
          },
        ],
        temperature: 0.3, // Lower temperature for more consistent outputs
        max_tokens: 1000,
      }),
    });

    if (!response.ok) {
      const errorText = await response.text();
      console.error("Groq API error:", errorText);
      return [];
    }

    const data = await response.json();
    const content = data.choices[0]?.message?.content;

    if (!content) {
      console.error("No content in Groq response");
      return [];
    }

    // Parse the JSON response
    let tasks: DetectedTask[];
    try {
      // Remove markdown code blocks if present
      const cleanContent = content.replace(/```json\n?|\n?```/g, "").trim();
      tasks = JSON.parse(cleanContent);
    } catch {
      console.error("Failed to parse AI response:", content);
      return [];
    }

    // Validate and return
    if (!Array.isArray(tasks)) {
      console.error("AI response is not an array:", tasks);
      return [];
    }

    return tasks;
  } catch (error) {
    console.error("Error calling Groq API:", error);
    return [];
  }
}

// Batch process unprocessed transcripts for a meeting
export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    const meetingId = searchParams.get("meetingId");

    if (!meetingId) {
      return NextResponse.json(
        { error: "Missing meetingId" },
        { status: 400 }
      );
    }

    // Get all unprocessed transcripts
    const transcripts = await getUnprocessedTranscripts(meetingId);

    if (transcripts.length === 0) {
      return NextResponse.json({
        success: true,
        message: "No unprocessed transcripts",
      });
    }

    // Combine transcripts into conversation context
    const combinedText = transcripts
      .map((t) => `${t.userName}: ${t.text}`)
      .join("\n");

    // Analyze combined text
    const detectedTasks = await analyzeTranscriptForTasks(
      combinedText
    );

    // Mark transcripts as processed
    for (const transcript of transcripts) {
      await markTranscriptProcessed(transcript.id);
    }

    // Create high-confidence tasks
    const createdTasks = [];
    for (const task of detectedTasks) {
      if (task.confidence >= 0.7) {
        const meeting = await getMeetingById(meetingId);
        if (!meeting) continue;

        const createdTask = await createTask({
          organizationId: meeting.organizationId,
          meetingId: meetingId,
          title: task.title,
          description: task.description,
          assignedBy: meeting.createdBy,
          status: "TODO",
          priority: task.priority,
          dueDate: task.dueDate,
          autoGenerated: true,
          tags: ["ai-generated", "meeting"],
        });

        createdTasks.push(createdTask);
      }
    }

    return NextResponse.json({
      success: true,
      transcriptsProcessed: transcripts.length,
      tasksDetected: detectedTasks.length,
      tasksCreated: createdTasks.length,
      tasks: createdTasks,
    });
  } catch (error) {
    console.error("Batch processing error:", error);
    return NextResponse.json(
      { error: "Batch processing failed" },
      { status: 500 }
    );
  }
}
